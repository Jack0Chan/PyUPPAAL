# support return typing MyTree
from __future__ import annotations
from typing import List


class MyTree:
    def __init__(self, sigma_o: List[str], n: int):
        """_summary_

        Args:
            sigma_o (List[str]): the set observation actions
            n (int): mat length of observation
        """
        self.sigma_o: List[str] = sigma_o
        self.n: int = n
        self.depth: int = 0
        self.observation_sequence: str = ""
        # whether the observation sequence in this node has been checked
        self.has_checked: bool = True
        # whether can be generated by the model
        self.is_valid: bool = True

        self.parent: MyTree = None
        self.children: List[MyTree] = []
        # self.grow()

    def grow(self) -> bool:
        if self.has_checked and self.is_valid and self.depth < self.n:
            for o in self.sigma_o:
                t = MyTree(sigma_o=self.sigma_o, n=self.n)
                t.depth = self.depth + 1
                t.observation_sequence += o
                t.has_checked = False

                t.parent = self
                self.children.append(t)
            return True
        else:
            return False

    @property
    def leftmost_not_verified_node(self) -> MyTree:
        """return the leftmost node that has not been verified. It is used for depth-first search.

        Returns:
            MyTree: _description_
        """
        if not self.has_checked:
            return self
        for child in self.children:
            result = child.leftmost_not_verified_node
            if result:
                return result
        return None

    @property
    def shadowest_not_verified_node(self) -> MyTree:
        """return the node that is not verified with the smallest depth. It is used for breadth-first search.

        Returns:
            MyTree: _description_
        """
        queue = [self]
        while queue:
            current_node = queue.pop(0)
            if not current_node.has_checked:
                return current_node
            queue.extend(current_node.children)
        return None

    def __repr__(self) -> str:
        return f"MyTree(depth:{self.depth}, has_checked: {self.has_checked}, is_valid: {self.is_valid}, observation_sequence: {self.observation_sequence})"


def test():
    sigma_o = ["a", "b", "c"]
    n = 3
    root = MyTree(sigma_o=sigma_o, n=3)
    if root.grow():
        while True:
            node = root.leftmost_not_verified_node
            if node is None:
                return True
            # check is valid observation sequence
            node.has_checked = True
            is_valid = True
            node.is_valid = is_valid
            if is_valid:
                # can detect:
                can_detect = True
                if not can_detect and node.depth == n:
                    return False
                else:
                    node.grow()


test()
